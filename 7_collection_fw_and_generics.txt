Java Collections Framework (JCF):
=================================
* The Java Collections Framework is a set of classes and interfaces in java.util that provides data structures (like lists, sets, maps) and algorithms (like sorting and searching).
* It helps developers manage groups of objects efficiently.


Key Interfaces in Collections:
==============================
Interface			Description								Common Implementations
Collection			Root interface for most collections		-
List				Ordered collection, allows duplicates	ArrayList, LinkedList, Vector, Stack
Set					Unordered collection, no duplicates		HashSet, LinkedHashSet, TreeSet
Queue				Follows FIFO, used for processing 
					elements in order						PriorityQueue, LinkedList
Deque				Double-ended queue
					(insert/remove at both ends)			ArrayDeque
Map					Key-Value pairs, keys are unique		HashMap, LinkedHashMap, TreeMap, Hashtable

Important Classes
=================
Collections (utility class): Provides static methods like Collections.sort() or Collections.reverse().
Arrays (utility class): Has methods for working with arrays (e.g., Arrays.asList()).

Example: Using a List:
======================
import java.util.*;

public class ListExample {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("John");
        names.add("Alice");
        names.add("Bob");
        
        for (String name : names) {
            System.out.println(name);
        }
    }
}

Example: Using a Set:
=====================
import java.util.*;

public class SetExample {
    public static void main(String[] args) {
        Set<Integer> numbers = new HashSet<>();
        numbers.add(10);
        numbers.add(20);
        numbers.add(10); // Duplicate ignored
        
        System.out.println(numbers);
    }
}

Example: Using a Map:
=====================
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Apple");
        map.put(2, "Banana");
        map.put(3, "Orange");
        
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " -> " + entry.getValue());
        }
    }
}


Generics in Collections:
========================
What Are Generics?
	Generics provide type safety and eliminate type casting in collections.
	Syntax: Collection<Type> (e.g., List<String>)
	Without generics, collections store Object type, requiring casting.
	
Advantages:
===========
* Type Safety: Ensures only the specified type is stored.
* No Casting: Retrieves objects directly as their type.
* Compile-time Checking: Detects type mismatch errors during compilation.

Example Without Generics (Old Way):
===================================
import java.util.*;

public class WithoutGenerics {
    public static void main(String[] args) {
        List list = new ArrayList(); // Raw type
        list.add("Hello");
        list.add(100); // No error at compile time
        
        for (Object obj : list) {
            String str = (String) obj; // Causes ClassCastException at runtime
            System.out.println(str);
        }
    }
}

Example With Generics:
======================
import java.util.*;

public class WithGenerics {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello");
        // list.add(100); // Compile-time error
        
        for (String str : list) {
            System.out.println(str); // No casting needed
        }
    }
}

Generic Map Example:
====================
import java.util.*;

public class GenericMap {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(101, "Laptop");
        map.put(102, "Tablet");
        
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            Integer key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + " => " + value);
        }
    }
}

Creating Your Own Generic Class:
================================
public class Box<T> {
    private T item;

    public Box(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }

    public void setItem(T item) {
        this.item = item;
    }

    public static void main(String[] args) {
        // Create a Box for String
        Box<String> stringBox = new Box<>("Hello Generics");
        System.out.println("String Box contains: " + stringBox.getItem());

        // Create a Box for Integer
        Box<Integer> intBox = new Box<>(100);
        System.out.println("Integer Box contains: " + intBox.getItem());
    }
}
