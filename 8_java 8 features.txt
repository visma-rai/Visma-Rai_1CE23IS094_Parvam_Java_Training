Java 8 features:
================
1. lambda expressions
2. functional interface
3. predicate
4. comsumer
5. supplier
6. Function
7. stream API
8. Optional

lambda expressions:
===================
1. it also called anonymous function(without name).
2. there is no return type
3. there is no access modifiers
* They provide a concise way to implement interfaces with a single method (functional interfaces)

1. 
public int add(int a , int b){
	return a+b;
}
(int a, int b)->{
	return a+b;
}

2. 
public int findLength(String s){
	return s.length();
}

(String s )-> { return s.length()}

3. 
public void print(){
	syso("Hello world");
}

()->{syso("Hello world")}


Important points:
=================
1. no need to specifiy the type of the data
(a,b)->{
	return a+b;
}
2. if the statment is single line then not require of {} and return
	(String s )-> { 
		return s.length()
	}
	(s)->s.length()
	
3. if you are passing the single paratmater then no nedd to ()
	s->s.length()

4. if there is no parameter then () is must.
	()->{syso("Hello world")}

5. if there is a multiple parameter then it need to seperate by ,
	(a,b)->a+b

Example Using Lambda in Collections:
====================================
import java.util.*;
public class LambdaDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Print all numbers
        numbers.forEach(n -> System.out.println(n));

        // Filter even numbers and print
        numbers.stream().filter(n -> n % 2 == 0).forEach(System.out::println);
    }
}


functional interface:
=====================
* Interface containn only one abstract method.
* Can have default and static methods.
* Annotate with @FunctionalInterface for clarity.

example: comparator.
* @FunctionalInterface -> functional interface

Example:
========
@FunctionalInterface
interface MyInterface {
    void display();
}

public class FuncInterfaceDemo {
    public static void main(String[] args) {
        MyInterface mi = () -> System.out.println("Hello Functional Interface");
        mi.display();
    }
}
* Common Examples: Comparator, Runnable


Method Reference:
=================
Method references are short-hand syntax for lambda expressions.
Syntax depends on the type of method
They are a shorthand syntax for lambda expressions that perform a single action.

Types:
======
1. Static Method Reference:
===========================
Syntax: ClassName::staticMethodReference

example:
========
	List<String> list = Arrays.asList("a", "b", "c");
	list.forEach(System.out::println);


2. Instance Method Reference of a Particular Object:
====================================================
Syntax: ObjName::instanceMethodReference

Example:
========
String msg = "Hello";
Runnable r = msg::toUpperCase; // reference to instance method


3. Instance Method Reference of an Arbitrary Object of a Particular Type:
=========================================================================
Syntax: ClassName::instanceMethodReference

* When we say “arbitrary object of a particular type”, it means the stream or collection will call the method on each object in it

ex:
===
	List<String> list = Arrays.asList("apple", "banana");
	list.sort(String::compareToIgnoreCase);





Constructor Reference:
======================
They are a shorthand syntax for lambda expressions that perform a single action.

Syntax: ClassName::new

ex:
===
import java.util.function.Supplier;

class Person {
    String name;
    Person() { this.name = "Unknown"; }
    Person(String name) { this.name = name; }
}

public class ConstructorRefDemo {
    public static void main(String[] args) {
        Supplier<Person> personSupplier = Person::new;
        Person p = personSupplier.get();
        System.out.println(p.name);
    }
}

Built-in Functional Interfaces:
===============================
* Java 8 provides four key functional interfaces in java.util.function.
1. Predicate<T>:
================
* Represents a boolean-valued function (condition check).

ex:
===
import java.util.function.Predicate;
public class PredicateDemo {
    public static void main(String[] args) {
        Predicate<Integer> isEven = n -> n % 2 == 0;
        System.out.println(isEven.test(10)); // true
        System.out.println(isEven.test(7));  // false
    }
}

2. Consumer<T>:
===============
* Represents an operation that accepts a single argument and returns nothing.

ex:
===
import java.util.function.Consumer;
public class ConsumerDemo {
    public static void main(String[] args) {
        Consumer<String> printer = s -> System.out.println(s);
        printer.accept("Hello World");
    }
}

3. Supplier<T>:
===============
* Represents a supplier of results (produces a value without input).
ex:
===
import java.util.function.Supplier;
import java.util.Random;

public class SupplierDemo {
    public static void main(String[] args) {
        Supplier<Integer> randomNumber = () -> new Random().nextInt(100);
        System.out.println(randomNumber.get());
    }
}

4. Function<T, R>:
==================
* Represents a function that accepts one argument and produces a result.
ex:
===
import java.util.function.Function;

public class FunctionDemo {
    public static void main(String[] args) {
        Function<String, Integer> lengthFunc = s -> s.length();
        System.out.println(lengthFunc.apply("Hello Java 8")); // 12
    }
}


collection:
===========
* to represent a group of individual objects as a single entity then we should go for collection.
streams:
========
* to work with multiple objects or collection then we should go for streams
* Streams allow processing sequences of elements in a functional style.
* Supports filtering, mapping, sorting, and aggregation.

1. source:
==========
* on which you are applying the stream
List<Integer> list = new ArrayList<>();
list.stream();

2. intermidiate operation:
==========================
* the opeartion will return the another stream, lazy opeartion

3. termination operation:
=========================
* it will terminate the stream
* after applyig the termination opeartion on streams we cannot reuse it.
* for each stream we can use only one termination operation.

example1:
=========
List<Integer> list = new ArrayList<>();
list.add(12);
list.add(10);
list.add(21);

list.stream().filter(x->x%2==0).count();

example2:
=========
import java.util.*;
import java.util.stream.*;

public class StreamDemo {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(12, 10, 21, 33, 44);

        // Filter even numbers
        long count = list.stream()
                         .filter(x -> x % 2 == 0)
                         .count();
        System.out.println("Even numbers count: " + count);

        // Map and print squares
        list.stream()
            .map(x -> x * x)
            .forEach(System.out::println);

        // Reduce to sum
        int sum = list.stream().reduce(0, Integer::sum);
        System.out.println("Sum: " + sum);
    }
}


What is Optional?:
==================
* Optional is a container object introduced in Java 8.
* It may or may not contain a non-null value.
* Helps avoid NullPointerException by explicitly handling missing values.
* Package: java.util.Optional

Why use Optional?:
==================
* Traditional null checks:
	String name = getName();
	if (name != null) {
		System.out.println(name.length());
	}
* With Optional:
================
	Optional<String> optionalName = getOptionalName();
	optionalName.ifPresent(name -> System.out.println(name.length()));


example:
========
import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args) {
        Optional<String> opt1 = Optional.of("Hello");
        Optional<String> opt2 = Optional.ofNullable(null);
        Optional<String> opt3 = Optional.empty();

        System.out.println(opt1); // Optional[Hello]
        System.out.println(opt2); // Optional.empty
        System.out.println(opt3); // Optional.empty
    }
}


Accessing Values in Optional:
=============================
1. isPresent() – checks if value exists

	if (opt1.isPresent()) {
		System.out.println(opt1.get());
	}


2. get() – retrieves value, throws NoSuchElementException if empty

3. ifPresent(Consumer) – executes action if value exists

	opt1.ifPresent(value -> System.out.println(value.length()));

4. orElse() – provides default value if empty

	String name = opt2.orElse("Default Name");
	System.out.println(name); // Default Name

5. orElseGet(Supplier) – lazy default value using lambda

	String name = opt2.orElseGet(() -> "Lazy Name");
	System.out.println(name);

6. orElseThrow(Supplier) – throws custom exception if empty

	opt2.orElseThrow(() -> new IllegalArgumentException("Value missing!"));